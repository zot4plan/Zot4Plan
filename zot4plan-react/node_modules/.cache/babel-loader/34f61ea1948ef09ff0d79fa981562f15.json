{"ast":null,"code":"import { invariant } from '@react-dnd/invariant';\nimport { matchesType } from '../../utils/matchesType';\nimport { HOVER } from './types';\nexport function createHover(manager) {\n  return function hover(targetIdsArg) {\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        clientOffset = _ref.clientOffset;\n\n    verifyTargetIdsIsArray(targetIdsArg);\n    var targetIds = targetIdsArg.slice(0);\n    var monitor = manager.getMonitor();\n    var registry = manager.getRegistry();\n    checkInvariants(targetIds, monitor, registry);\n    var draggedItemType = monitor.getItemType();\n    removeNonMatchingTargetIds(targetIds, registry, draggedItemType);\n    hoverAllTargets(targetIds, monitor, registry);\n    return {\n      type: HOVER,\n      payload: {\n        targetIds: targetIds,\n        clientOffset: clientOffset || null\n      }\n    };\n  };\n}\n\nfunction verifyTargetIdsIsArray(targetIdsArg) {\n  invariant(Array.isArray(targetIdsArg), 'Expected targetIds to be an array.');\n}\n\nfunction checkInvariants(targetIds, monitor, registry) {\n  invariant(monitor.isDragging(), 'Cannot call hover while not dragging.');\n  invariant(!monitor.didDrop(), 'Cannot call hover after drop.');\n\n  for (var i = 0; i < targetIds.length; i++) {\n    var targetId = targetIds[i];\n    invariant(targetIds.lastIndexOf(targetId) === i, 'Expected targetIds to be unique in the passed array.');\n    var target = registry.getTarget(targetId);\n    invariant(target, 'Expected targetIds to be registered.');\n  }\n}\n\nfunction removeNonMatchingTargetIds(targetIds, registry, draggedItemType) {\n  // Remove those targetIds that don't match the targetType.  This\n  // fixes shallow isOver which would only be non-shallow because of\n  // non-matching targets.\n  for (var i = targetIds.length - 1; i >= 0; i--) {\n    var targetId = targetIds[i];\n    var targetType = registry.getTargetType(targetId);\n\n    if (!matchesType(targetType, draggedItemType)) {\n      targetIds.splice(i, 1);\n    }\n  }\n}\n\nfunction hoverAllTargets(targetIds, monitor, registry) {\n  // Finally call hover on all matching targets.\n  targetIds.forEach(function (targetId) {\n    var target = registry.getTarget(targetId);\n    target.hover(monitor, targetId);\n  });\n}","map":{"version":3,"sources":["/Users/tramla/Desktop/Zot4Plan/zot4plan-react/node_modules/dnd-core/dist/esm/actions/dragDrop/hover.js"],"names":["invariant","matchesType","HOVER","createHover","manager","hover","targetIdsArg","_ref","arguments","length","undefined","clientOffset","verifyTargetIdsIsArray","targetIds","slice","monitor","getMonitor","registry","getRegistry","checkInvariants","draggedItemType","getItemType","removeNonMatchingTargetIds","hoverAllTargets","type","payload","Array","isArray","isDragging","didDrop","i","targetId","lastIndexOf","target","getTarget","targetType","getTargetType","splice","forEach"],"mappings":"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","sourcesContent":["import { invariant } from '@react-dnd/invariant';\nimport { matchesType } from '../../utils/matchesType';\nimport { HOVER } from './types';\nexport function createHover(manager) {\n  return function hover(targetIdsArg) {\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        clientOffset = _ref.clientOffset;\n\n    verifyTargetIdsIsArray(targetIdsArg);\n    var targetIds = targetIdsArg.slice(0);\n    var monitor = manager.getMonitor();\n    var registry = manager.getRegistry();\n    checkInvariants(targetIds, monitor, registry);\n    var draggedItemType = monitor.getItemType();\n    removeNonMatchingTargetIds(targetIds, registry, draggedItemType);\n    hoverAllTargets(targetIds, monitor, registry);\n    return {\n      type: HOVER,\n      payload: {\n        targetIds: targetIds,\n        clientOffset: clientOffset || null\n      }\n    };\n  };\n}\n\nfunction verifyTargetIdsIsArray(targetIdsArg) {\n  invariant(Array.isArray(targetIdsArg), 'Expected targetIds to be an array.');\n}\n\nfunction checkInvariants(targetIds, monitor, registry) {\n  invariant(monitor.isDragging(), 'Cannot call hover while not dragging.');\n  invariant(!monitor.didDrop(), 'Cannot call hover after drop.');\n\n  for (var i = 0; i < targetIds.length; i++) {\n    var targetId = targetIds[i];\n    invariant(targetIds.lastIndexOf(targetId) === i, 'Expected targetIds to be unique in the passed array.');\n    var target = registry.getTarget(targetId);\n    invariant(target, 'Expected targetIds to be registered.');\n  }\n}\n\nfunction removeNonMatchingTargetIds(targetIds, registry, draggedItemType) {\n  // Remove those targetIds that don't match the targetType.  This\n  // fixes shallow isOver which would only be non-shallow because of\n  // non-matching targets.\n  for (var i = targetIds.length - 1; i >= 0; i--) {\n    var targetId = targetIds[i];\n    var targetType = registry.getTargetType(targetId);\n\n    if (!matchesType(targetType, draggedItemType)) {\n      targetIds.splice(i, 1);\n    }\n  }\n}\n\nfunction hoverAllTargets(targetIds, monitor, registry) {\n  // Finally call hover on all matching targets.\n  targetIds.forEach(function (targetId) {\n    var target = registry.getTarget(targetId);\n    target.hover(monitor, targetId);\n  });\n}"]},"metadata":{},"sourceType":"module"}